package penetration

import (
	"crypto/tls"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
)

// VulnerabilityLevel represents the severity of a vulnerability
type VulnerabilityLevel int

const (
	Low VulnerabilityLevel = iota
	Medium
	High
	Critical
)

func (v VulnerabilityLevel) String() string {
	switch v {
	case Low:
		return "LOW"
	case Medium:
		return "MEDIUM"
	case High:
		return "HIGH"
	case Critical:
		return "CRITICAL"
	default:
		return "UNKNOWN"
	}
}

// Vulnerability represents a security vulnerability
type Vulnerability struct {
	ID          string
	Name        string
	Description string
	Level       VulnerabilityLevel
	Endpoint    string
	Payload     string
	Response    string
}

// VulnerabilityTestSuite contains penetration tests
type VulnerabilityTestSuite struct {
	suite.Suite
	baseURL         string
	client          *http.Client
	vulnerabilities []Vulnerability
}

// SetupSuite initializes the test suite
func (suite *VulnerabilityTestSuite) SetupSuite() {
	suite.baseURL = "http://localhost:8080"
	suite.client = &http.Client{
		Timeout: 10 * time.Second,
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		},
	}
	suite.vulnerabilities = []Vulnerability{}
}

// TestSQLInjectionVulnerabilities tests for SQL injection vulnerabilities
func (suite *VulnerabilityTestSuite) TestSQLInjectionVulnerabilities() {
	sqlPayloads := []string{
		"'; DROP TABLE users; --",
		"' OR '1'='1",
		"' UNION SELECT * FROM users --",
		"'; INSERT INTO users VALUES ('hacker', 'password'); --",
	}

	for _, payload := range sqlPayloads {
		resp, err := suite.client.Get(fmt.Sprintf("%s/api/v1/search?q=%s", suite.baseURL, url.QueryEscape(payload)))
		if err != nil {
			continue
		}
		defer resp.Body.Close()

		// If the server doesn't return 400, it might be vulnerable
		if resp.StatusCode != http.StatusBadRequest {
			vuln := Vulnerability{
				ID:          fmt.Sprintf("SQL_INJ_%d", len(suite.vulnerabilities)+1),
				Name:        "SQL Injection",
				Description: "Endpoint may be vulnerable to SQL injection",
				Level:       Critical,
				Endpoint:    "/api/v1/search",
				Payload:     payload,
				Response:    fmt.Sprintf("Status: %d", resp.StatusCode),
			}
			suite.vulnerabilities = append(suite.vulnerabilities, vuln)
		}
	}
}

// TestXSSVulnerabilities tests for XSS vulnerabilities
func (suite *VulnerabilityTestSuite) TestXSSVulnerabilities() {
	xssPayloads := []string{
		"<script>alert('xss')</script>",
		"<img src=x onerror=alert('xss')>",
		"javascript:alert('xss')",
	}

	for _, payload := range xssPayloads {
		resp, err := suite.client.Get(fmt.Sprintf("%s/api/v1/search?q=%s", suite.baseURL, url.QueryEscape(payload)))
		if err != nil {
			continue
		}
		defer resp.Body.Close()

		// Check if payload is reflected in response
		body := make([]byte, 1024)
		n, _ := resp.Body.Read(body)
		responseBody := string(body[:n])

		if strings.Contains(responseBody, payload) {
			vuln := Vulnerability{
				ID:          fmt.Sprintf("XSS_%d", len(suite.vulnerabilities)+1),
				Name:        "Cross-Site Scripting",
				Description: "Endpoint reflects user input without proper sanitization",
				Level:       High,
				Endpoint:    "/api/v1/search",
				Payload:     payload,
				Response:    responseBody,
			}
			suite.vulnerabilities = append(suite.vulnerabilities, vuln)
		}
	}
}

// TestPathTraversalVulnerabilities tests for path traversal vulnerabilities
func (suite *VulnerabilityTestSuite) TestPathTraversalVulnerabilities() {
	pathPayloads := []string{
		"../../../etc/passwd",
		"..\\..\\..\\windows\\system32\\config\\sam",
		"%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
	}

	for _, payload := range pathPayloads {
		resp, err := suite.client.Get(fmt.Sprintf("%s/api/v1/search?file=%s", suite.baseURL, url.QueryEscape(payload)))
		if err != nil {
			continue
		}
		defer resp.Body.Close()

		// If the server doesn't return 400, it might be vulnerable
		if resp.StatusCode != http.StatusBadRequest {
			vuln := Vulnerability{
				ID:          fmt.Sprintf("PATH_TRAV_%d", len(suite.vulnerabilities)+1),
				Name:        "Path Traversal",
				Description: "Endpoint may be vulnerable to path traversal attacks",
				Level:       High,
				Endpoint:    "/api/v1/search",
				Payload:     payload,
				Response:    fmt.Sprintf("Status: %d", resp.StatusCode),
			}
			suite.vulnerabilities = append(suite.vulnerabilities, vuln)
		}
	}
}

// TestSecurityHeaders tests for missing security headers
func (suite *VulnerabilityTestSuite) TestSecurityHeaders() {
	resp, err := suite.client.Get(fmt.Sprintf("%s/api/v1/health", suite.baseURL))
	if err != nil {
		return
	}
	defer resp.Body.Close()

	requiredHeaders := map[string]string{
		"X-Content-Type-Options":    "nosniff",
		"X-Frame-Options":           "DENY",
		"X-XSS-Protection":          "1; mode=block",
		"Strict-Transport-Security": "max-age=31536000",
	}

	for header, expectedValue := range requiredHeaders {
		actualValue := resp.Header.Get(header)
		if actualValue == "" || actualValue != expectedValue {
			vuln := Vulnerability{
				ID:          fmt.Sprintf("SEC_HEADER_%s", header),
				Name:        "Missing Security Header",
				Description: fmt.Sprintf("Missing or incorrect %s header", header),
				Level:       Medium,
				Endpoint:    "/api/v1/health",
				Payload:     "N/A",
				Response:    fmt.Sprintf("Expected: %s, Got: %s", expectedValue, actualValue),
			}
			suite.vulnerabilities = append(suite.vulnerabilities, vuln)
		}
	}
}

// TearDownSuite generates vulnerability report
func (suite *VulnerabilityTestSuite) TearDownSuite() {
	if len(suite.vulnerabilities) > 0 {
		fmt.Printf("\n=== VULNERABILITY ASSESSMENT REPORT ===\n")
		for _, vuln := range suite.vulnerabilities {
			fmt.Printf("[%s] %s - %s\n", vuln.Level, vuln.Name, vuln.Description)
			fmt.Printf("  Endpoint: %s\n", vuln.Endpoint)
			fmt.Printf("  Payload: %s\n", vuln.Payload)
			fmt.Printf("  Response: %s\n\n", vuln.Response)
		}
		// Fail the test if critical vulnerabilities are found
		for _, vuln := range suite.vulnerabilities {
			if vuln.Level == Critical {
				assert.Fail(suite.T(), "Critical vulnerability found", vuln.Description)
			}
		}
	} else {
		fmt.Printf("\n=== NO VULNERABILITIES DETECTED ===\n")
	}
}

// TestVulnerabilityAssessment runs the vulnerability assessment suite
func TestVulnerabilityAssessment(t *testing.T) {
	suite.Run(t, new(VulnerabilityTestSuite))
}
